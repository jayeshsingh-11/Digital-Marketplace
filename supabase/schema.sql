-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- PUBLIC USERS TABLE (Extends auth.users)
-- PUBLIC USERS TABLE (Extends auth.users)
create table public.users (
  id uuid references auth.users on delete cascade not null primary key,
  role text check (role in ('admin', 'user')) default 'user',
  stripe_customer_id text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Secure function to check admin status (Prevents recursion)
create or replace function public.is_admin()
returns boolean 
language plpgsql 
security definer 
as $$
begin
  return exists (
    select 1 
    from public.users 
    where id = auth.uid() 
    and role = 'admin'
  );
end;
$$;

-- RLS for Users
alter table public.users enable row level security;
create policy "Users can view their own profile" on public.users for select using (auth.uid() = id);
create policy "Admins can view all profiles" on public.users for select using (public.is_admin());

-- ... (Trigger omitted as it's unchanged) ...

-- PRODUCTS TABLE
create table public.products (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.users(id) on delete cascade not null,
  name text not null,
  description text,
  price numeric not null,
  category text not null,
  approved boolean default true, -- Default to true
  price_id text,
  stripe_id text,
  product_file_id uuid references public.product_files(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.products enable row level security;
create policy "Public read approved products" on public.products for select using (approved = true);
create policy "Users manage own products" on public.products for all using (auth.uid() = user_id);
create policy "Admins manage all" on public.products for all using (public.is_admin());


-- PRODUCT IMAGES (One-to-Many)
create table public.product_images (
  id uuid default uuid_generate_v4() primary key,
  product_id uuid references public.products(id) on delete cascade not null,
  image_id uuid references public.media(id) on delete cascade not null,
  "order" integer default 0
);
alter table public.product_images enable row level security;
create policy "Public read" on public.product_images for select using (true);
create policy "Users manage own" on public.product_images for all using (
  exists (select 1 from public.products where id = product_images.product_id and user_id = auth.uid())
);


-- ORDERS TABLE
create table public.orders (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references public.users(id) on delete set null,
  is_paid boolean default false,
  amount numeric,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.orders enable row level security;
create policy "Users view own orders" on public.orders for select using (auth.uid() = user_id);
create policy "Admins view all" on public.orders for select using (
  exists (select 1 from public.users where id = auth.uid() and role = 'admin')
);


-- ORDER PRODUCTS (Many-to-Many)
create table public.order_products (
  order_id uuid references public.orders(id) on delete cascade not null,
  product_id uuid references public.products(id) on delete set null,
  primary key (order_id, product_id)
);
alter table public.order_products enable row level security;
create policy "Users view own order items" on public.order_products for select using (
  exists (select 1 from public.orders where id = order_products.order_id and user_id = auth.uid())
);

-- STORAGE BUCKETS (Insert into storage.buckets)
insert into storage.buckets (id, name, public) values ('media', 'media', true) on conflict do nothing;
insert into storage.buckets (id, name, public) values ('product_files', 'product_files', false) on conflict do nothing;

-- Storage Policies
create policy "Media Public Read" on storage.objects for select using (bucket_id = 'media');
create policy "Media Auth Upload" on storage.objects for insert with check (bucket_id = 'media' and auth.role() = 'authenticated');
create policy "Product Files Auth Upload" on storage.objects for insert with check (bucket_id = 'product_files' and auth.role() = 'authenticated');
-- Download of product files will be via signed URLs generated by the server
